AWSTemplateFormatVersion: '2010-09-09'
Description: "Managed AWS Config rule (EC2_VOLUME_INUSE_CHECK) for EBS Volumes with SSM remediation. Dynamic naming OMBASR-* pattern."

Parameters:
  Team:
    Type: String
    Default: hcops
    Description: "Team identifier (e.g., hcops, sec, plat)."
  Service:
    Type: String
    Default: ec2
    Description: "Service identifier (e.g., ec2, iam, s3)."
  Purpose:
    Type: String
    Default: volinuse
    Description: "Purpose suffix (e.g., volinuse)."

Resources:
  ########################################
  # 1) Managed Config rule
  ########################################
  VolumeInUseRule:
    Type: AWS::Config::ConfigRule
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      ConfigRuleName: !Sub "OMBASR-Configrule-${Team}-${Service}${Purpose}"
      Description: !Sub "Ensure EBS volumes are attached (EC2_VOLUME_INUSE_CHECK) for ${Team}/${Purpose}."
      Scope:
        ComplianceResourceTypes:
          - AWS::EC2::Volume
      Source:
        Owner: AWS
        SourceIdentifier: EC2_VOLUME_INUSE_CHECK

  ########################################
  # 2) Remediation IAM role  (ADD SecurityHub permission)
  ########################################
  RemediationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "OMBASR-RoleRemediate-${Team}-${Service}${Purpose}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "OMBASR-Remediate-${Team}-${Service}${Purpose}"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Read & delete volumes
              - Effect: Allow
                Action:
                  - ec2:DescribeVolumes
                  - ec2:DeleteVolume
                Resource: "*"
              # Resolve Security Hub finding
              - Effect: Allow
                Action:
                  - securityhub:BatchUpdateFindings
                Resource: "*"
              # Logging
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  ########################################
  # 3) SSM Automation document (Security Hub → Delete unattached volume → Resolve)
  ########################################
  DeleteUnusedVolumeDoc:
    Type: AWS::SSM::Document
    Properties:
      Name: !Sub "OMBASR-SSMDocRemediate-${Team}-${Service}${Purpose}"
      DocumentType: Automation
      DocumentFormat: YAML
      Content:
        # Keep as MAP (not multiline string) so SSM sees mainSteps
        schemaVersion: '0.3'
        description: !Sub >
          Parse Security Hub findings for unattached EBS volumes, delete if 'available',
          then mark the finding RESOLVED for ${Team}/${Purpose}.
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          # Pass this in from the invoker (EventBridge/Lambda). You may set a default if you prefer.
          AutomationAssumeRole:
            type: String
            description: "Role that Automation assumes to perform actions."
          AccountId:
            type: String
            default: ""
            description: "AWS account of the finding (optional)."
          Region:
            type: String
            default: ""
            description: "Event region (optional)."
          FindingsJson:
            type: String
            description: "Security Hub findings array (ASFF) as JSON string."
          DryRun:
            type: Boolean
            default: true
            description: "If true, only validate and annotate the finding; do not delete."
        mainSteps:
          - name: ParseFindings
            description: "Extract first finding, ProductArn, Id, and AwsEc2Volume id."
            action: aws:executeScript
            nextStep: CheckIfVolumeFound
            inputs:
              Runtime: python3.8
              Handler: handler
              InputPayload:
                findings_json: "{{ FindingsJson }}"
              Script: |
                def handler(event, context):
                    import json
                    findings = event.get("findings_json")
                    findings = json.loads(findings) if isinstance(findings, str) else findings
                    if not findings:
                        return {"FindingId": "", "ProductArn": "", "VolumeId": ""}

                    f = findings[0]
                    fid = f.get("Id", "")
                    parn = f.get("ProductArn", "")
                    vol_id = ""

                    # Extract EBS Volume from ASFF resources (type AwsEc2Volume)
                    for r in f.get("Resources", []):
                        if r.get("Type") == "AwsEc2Volume":
                            rid = r.get("Id") or ""
                            # Id may be 'vol-xxxx' or an ARN; normalize to 'vol-xxxx'
                            if rid.startswith("arn:"):
                                rid = rid.split("/")[-1]
                            vol_id = rid
                            break

                    return {"FindingId": fid, "ProductArn": parn, "VolumeId": vol_id}
            outputs:
              - Name: FindingId
                Selector: $.Payload.FindingId
                Type: String
              - Name: ProductArn
                Selector: $.Payload.ProductArn
                Type: String
              - Name: VolumeId
                Selector: $.Payload.VolumeId
                Type: String

          - name: CheckIfVolumeFound
            action: aws:branch
            inputs:
              Choices:
                # If no VolumeId in finding, still resolve to clear stale records
                - NextStep: ResolveFindings
                  Variable: "{{ ParseFindings.VolumeId }}"
                  StringEquals: ""
              Default: DescribeVolume

          - name: DescribeVolume
            description: "Describe volume to verify it is 'available' (unattached)."
            action: aws:executeScript
            nextStep: CheckAvailability
            inputs:
              Runtime: python3.8
              Handler: handler
              InputPayload:
                volume_id: "{{ ParseFindings.VolumeId }}"
              Script: |
                def handler(event, context):
                    import boto3
                    from botocore.exceptions import ClientError
                    vol_id = event.get("volume_id")
                    ec2 = boto3.client("ec2")
                    try:
                        resp = ec2.describe_volumes(VolumeIds=[vol_id])
                        vols = resp.get("Volumes", [])
                        if not vols:
                            return {"State": "not-found", "IsAvailable": "false"}
                        v = vols[0]
                        state = v.get("State", "unknown")
                        is_avail = (state == "available" and not v.get("Attachments"))
                        return {"State": state, "IsAvailable": "true" if is_avail else "false"}
                    except ClientError as e:
                        return {"State": "error", "IsAvailable": "false", "Error": str(e)}
            outputs:
              - Name: IsAvailable
                Selector: $.Payload.IsAvailable
                Type: String
              - Name: State
                Selector: $.Payload.State
                Type: String

          - name: CheckAvailability
            action: aws:branch
            inputs:
              Choices:
                # If not available (already attached/deleting/etc.), just resolve the finding
                - NextStep: ResolveFindings
                  Variable: "{{ DescribeVolume.IsAvailable }}"
                  StringEquals: "false"
              Default: CheckDryRun

          - name: CheckDryRun
            action: aws:branch
            inputs:
              Choices:
                - NextStep: ResolveFindings
                  Variable: "{{ DryRun }}"
                  StringEquals: "true"
              Default: DeleteVolume

          - name: DeleteVolume
            description: "Delete unattached EBS volume."
            action: aws:executeAwsApi
            nextStep: ResolveFindings
            inputs:
              Service: ec2
              Api: DeleteVolume
              VolumeId: "{{ ParseFindings.VolumeId }}"

          - name: ResolveFindings
            description: "Mark the Security Hub finding as RESOLVED."
            action: aws:executeAwsApi
            isEnd: true
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - ProductArn: "{{ ParseFindings.ProductArn }}"
                  Id: "{{ ParseFindings.FindingId }}"
              Workflow:
                Status: RESOLVED
              Note:
                UpdatedBy: OMBASR-Automation
                Text: >-
                  EC2_VOLUME_INUSE_CHECK: evaluated via Automation for volume
                  '{{ ParseFindings.VolumeId }}'. DryRun={{ DryRun }}.

  ########################################
  # 4) Config RemediationConfiguration (NOT USED with Security Hub runbook)
  ########################################
  # This runbook expects Security Hub 'FindingsJson' and cannot be invoked by
  # AWS Config RemediationConfiguration. Trigger via EventBridge/Lambda instead.
  #
  # VolumeInUseRemediation:
  #   Type: AWS::Config::RemediationConfiguration
  #   DependsOn:
  #     - RemediationRole
  #     - DeleteUnusedVolumeDoc
  #   Properties:
  #     ConfigRuleName: !Ref VolumeInUseRule
  #     ResourceType: AWS::EC2::Volume
  #     TargetType: SSM_DOCUMENT
  #     TargetId: !Ref DeleteUnusedVolumeDoc
  #     TargetVersion: "$DEFAULT"
  #     Automatic: false
  #     ExecutionControls:
  #       SsmControls:
  #         ConcurrentExecutionRatePercentage: 10
  #         ErrorPercentage: 10
  #     Parameters:
  #       AutomationAssumeRole:
  #         StaticValue:
  #           Values: [ !GetAtt RemediationRole.Arn ]
  #       # This mapping works only for Config-triggered docs; not applicable here.
  #       VolumeId:
  #         ResourceValue:
  #           Value: RESOURCE_ID

Outputs:
  ManagedRuleName:
    Value: !Ref VolumeInUseRule
  RemediationDocumentName:
    Value: !Ref DeleteUnusedVolumeDoc
  RemediationRoleArn:
    Value: !GetAtt RemediationRole.Arn
