AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Managed AWS Config rule + SSM Automation (Security Hub remediation example).
  OMBASR-* dynamic naming. NOTE: The included SSM runbook expects Security Hub FindingsJson
  and is not directly invocable via AWS Config RemediationConfiguration.

Parameters:
  Team:
    Type: String
    Default: hcops
    Description: "Team identifier (e.g., hcops, sec, plat)."
  Service:
    Type: String
    Default: ec2
    Description: "Service identifier (e.g., ec2, iam, s3)."
  Purpose:
    Type: String
    Default: supporttagcheck
    Description: "Purpose suffix (e.g., volinuse, supporttagcheck)."

Resources:
  ########################################
  # 1) Managed Config rule (example)
  ########################################
  VolumeInUseRule:
    Type: AWS::Config::ConfigRule
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      # CHANGE HERE for other managed rules:
      # - SourceIdentifier: set to the AWS managed rule you want (e.g., S3_BUCKET_VERSIONING_ENABLED)
      # - Scope: adjust ResourceTypes or TagKey/TagValue etc.
      # - ConfigRuleName: keep your naming pattern but tweak Service/Purpose as needed
      ConfigRuleName: !Sub "OMBASR-Configrule-${Team}-${Service}${Purpose}"
      Description: !Sub "Example managed rule (EC2_VOLUME_INUSE_CHECK) for ${Team}/${Purpose}."
      Scope:
        ComplianceResourceTypes:
          - AWS::EC2::Volume
      Source:
        Owner: AWS
        SourceIdentifier: EC2_VOLUME_INUSE_CHECK

  ########################################
  # 2) Remediation IAM role for the SSM runbook
  ########################################
  RemediationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "OMBASR-RoleRemediate-${Team}-${Service}${Purpose}"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub "OMBASR-Remediate-${Team}-${Service}${Purpose}"
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # For tagging the EC2 instance
              - Effect: Allow
                Action:
                  - ec2:CreateTags
                  - ec2:DescribeInstances
                Resource: "*"
              # To resolve the Security Hub finding
              - Effect: Allow
                Action:
                  - securityhub:BatchUpdateFindings
                Resource: "*"
              # Logging
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  ########################################
  # 3) SSM Automation document (Security Hub -> Tag EC2 -> Resolve)
  ########################################
  TagAndResolveFindingDoc:
    Type: AWS::SSM::Document
    Properties:
      Name: !Sub "OMBASR-SSMDocRemediate-${Team}-${Service}${Purpose}"
      DocumentType: Automation
      DocumentFormat: YAML
      Content:
        # Keep this as a YAML MAP (not a multiline string), so SSM sees mainSteps
        schemaVersion: '0.3'
        description: >
          Parse Security Hub findings, tag EC2 instance with Name if present, and resolve findings.
          Skips tagging if no EC2 instance present.
        # IMPORTANT: don't hardcode the role here; take it from parameter
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          # CHANGE HERE for your environment:
          # - You can leave the default blank and pass the role ARN from your invoker (Lambda/EventBridge target)
          # - Or set a default with your account ID below
          AutomationAssumeRole:
            type: String
            description: "Role that Automation assumes to perform actions."
            # default: arn:aws:iam::<ACCOUNT_ID>:role/OMBASR-RoleRemediate-<team>-<svc><purpose>
          AccountId:
            type: String
            description: "AWS account of the finding."
            default: ""
          Region:
            type: String
            description: "Event region."
            default: ""
          FindingsJson:
            type: String
            description: "JSON string of the Security Hub findings array."
        mainSteps:
          - name: ParseFindings
            description: Extract first finding, resource details, product ARN, and finding ID.
            action: aws:executeScript
            nextStep: CheckIfInstanceFound
            isEnd: false
            inputs:
              # Use a widely supported runtime
              Runtime: python3.8
              Handler: handler
              InputPayload:
                FindingsJson: "{{ FindingsJson }}"
              Script: |
                def handler(event, context):
                    import json
                    findings = json.loads(event['FindingsJson']) if isinstance(event.get('FindingsJson'), str) else event.get('FindingsJson')
                    if not findings:
                        return {"error": "NoFindings"}
                    f = findings[0]
                    out = {
                        "FindingId": f.get("Id"),
                        "ProductArn": f.get("ProductArn"),
                        "Region": f.get("Region"),
                        "InstanceId": None
                    }
                    # Look for EC2 instance resource
                    for r in f.get("Resources", []):
                        if r.get("Type") == "AwsEc2Instance":
                            rid = r.get("Id") or ""
                            if rid.startswith("arn:"):
                                rid = rid.split("/")[-1]
                            out["InstanceId"] = rid
                            break
                    return out
            outputs:
              - Name: FindingId
                Selector: $.Payload.FindingId
                Type: String
              - Name: ProductArn
                Selector: $.Payload.ProductArn
                Type: String
              - Name: InstanceId
                Selector: $.Payload.InstanceId
                Type: String

          - name: CheckIfInstanceFound
            action: aws:branch
            inputs:
              Choices:
                # If InstanceId is empty -> resolve only
                - NextStep: ResolveFindings
                  Variable: "{{ ParseFindings.InstanceId }}"
                  StringEquals: ""
              Default: AddNameTag

          - name: AddNameTag
            description: Add the 'Name' tag to the EC2 instance (idempotent).
            action: aws:executeAwsApi
            nextStep: ResolveFindings
            isEnd: false
            inputs:
              Service: ec2
              Api: CreateTags
              Resources:
                - "{{ ParseFindings.InstanceId }}"
              Tags:
                - Key: Name
                  Value: "{{ ParseFindings.InstanceId }}"

          - name: ResolveFindings
            description: Mark the related Security Hub finding as RESOLVED.
            action: aws:executeAwsApi
            isEnd: true
            inputs:
              Service: securityhub
              Api: BatchUpdateFindings
              FindingIdentifiers:
                - ProductArn: "{{ ParseFindings.ProductArn }}"
                  Id: "{{ ParseFindings.FindingId }}"
              Workflow:
                Status: RESOLVED
              Note:
                UpdatedBy: OMBASR-Automation
                Text: Remediated via OMBASR Automation

  ########################################
  # 4) AWS Config â†’ SSM remediation wiring
  ########################################
  # NOTE: This runbook expects FindingsJson from Security Hub and therefore
  # cannot be invoked via AWS Config RemediationConfiguration.
  # To auto-run this runbook, use:
  #   a) EventBridge rule on Security Hub events that calls StartAutomationExecution, OR
  #   b) A Lambda that receives findings and starts the runbook with Inputs:
  #        AutomationAssumeRole = !GetAtt RemediationRole.Arn
  #        FindingsJson        = <the findings array as JSON string>
  #
  # If you DO want a Config-driven remediation instead:
  # - Use a different runbook that accepts parameters like ResourceId/VolumeId/etc.
  # - Then (uncomment + adapt) the block below and map those parameters.
  #
  # VolumeInUseRemediation:
  #   Type: AWS::Config::RemediationConfiguration
  #   DependsOn:
  #     - RemediationRole
  #     - TagAndResolveFindingDoc
  #   Properties:
  #     ConfigRuleName: !Ref VolumeInUseRule           # CHANGE HERE if you switch to a different rule
  #     ResourceType: AWS::EC2::Volume                 # CHANGE HERE to your resource type
  #     TargetType: SSM_DOCUMENT
  #     TargetId: !Ref TagAndResolveFindingDoc         # CHANGE HERE to a Config-friendly runbook
  #     TargetVersion: "$DEFAULT"
  #     Automatic: false
  #     ExecutionControls:
  #       SsmControls:
  #         ConcurrentExecutionRatePercentage: 10
  #         ErrorPercentage: 10
  #     Parameters:
  #       AutomationAssumeRole:
  #         StaticValue:
  #           Values: [ !GetAtt RemediationRole.Arn ]
  #       # Map resource identifiers from the Config finding (example)
  #       VolumeId:
  #         ResourceValue:
  #           Value: RESOURCE_ID

Outputs:
  ManagedRuleName:
    Value: !Ref VolumeInUseRule
  RemediationDocumentName:
    Value: !Ref TagAndResolveFindingDoc
  RemediationRoleArn:
    Value: !GetAtt RemediationRole.Arn
