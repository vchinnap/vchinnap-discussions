AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Streaming Chat (Claude 3.5 via Amazon Bedrock) exposed through a Lambda Function URL using SSE.
  Enterprise defaults: least-privilege IAM, log retention, optional API key check.

Parameters:
  BedrockRegion:
    Type: String
    Default: "AUTO"
    AllowedPattern: '^[A-Za-z0-9-]+$'
    Description: 'Region to call Bedrock. Use a concrete region like "us-east-1", or leave "AUTO" to use the stack region.'
  TextModelId:
    Type: String
    Default: "anthropic.claude-3-5-sonnet-20240620"
    Description: 'Bedrock text model id (e.g., "anthropic.claude-3-5-sonnet-20240620").'
  AppApiKey:
    Type: String
    Default: ""
    NoEcho: true
    Description: 'Optional API key; if set, requests must send header X-API-Key with this value.'

Conditions:
  UseAutoRegion: !Equals [ !Ref BedrockRegion, "AUTO" ]

Mappings:
  PartitionMap:
    aws:
      Partition: "aws"
    aws-us-gov:
      Partition: "aws-us-gov"
    aws-cn:
      Partition: "aws-cn"

Resources:
  ChatRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub HOPS-StreamingChatRole-${AWS::StackName}
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockInvokeStream
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: InvokeClaudeStream
                Effect: Allow
                Action:
                  - bedrock:InvokeModelWithResponseStream
                  - bedrock:InvokeModel
                Resource:
                  - !Sub
                    - arn:${Partition}:bedrock:${UseRegion}::foundation-model/${TextModelId}
                    - {
                        Partition: !FindInMap [ PartitionMap, !Ref AWS::Partition, Partition ],
                        UseRegion: !If [ UseAutoRegion, !Ref AWS::Region, !Ref BedrockRegion ]
                      }

  ChatFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub HOPS-StreamingChat-${AWS::StackName}
      Role: !GetAtt ChatRole.Arn
      Runtime: nodejs20.x
      Handler: index.handler
      Timeout: 120
      MemorySize: 1024
      TracingConfig: { Mode: Active }
      Environment:
        Variables:
          BEDROCK_REGION: !If [ UseAutoRegion, !Ref AWS::Region, !Ref BedrockRegion ]
          TEXT_MODEL_ID: !Ref TextModelId
          APP_API_KEY: !Ref AppApiKey
      Code:
        ZipFile: |
          'use strict';
          const AWS = require('aws-sdk');
          const bedrock = new AWS.BedrockRuntime({ region: process.env.BEDROCK_REGION || process.env.AWS_REGION });
          const MODEL_ID = process.env.TEXT_MODEL_ID || 'anthropic.claude-3-5-sonnet-20240620';
          const API_KEY = process.env.APP_API_KEY || '';

          // Lambda Response Streaming (Node 18+/20+)
          exports.handler = awslambda.streamifyResponse(async (event, responseStream) => {
            const headers = {
              "content-type": "text/event-stream; charset=utf-8",
              "cache-control": "no-cache, no-store, must-revalidate",
              "pragma": "no-cache",
              "access-control-allow-origin": "*",
              "access-control-allow-headers": "content-type,x-api-key,X-API-Key",
              "access-control-allow-methods": "POST,OPTIONS"
            };
            awslambda.HttpResponseStream.from(responseStream, { statusCode: 200, headers });

            try {
              // CORS preflight
              if (event.requestContext?.http?.method === 'OPTIONS') {
                responseStream.end(); return;
              }

              // Optional API key gate
              if (API_KEY) {
                const hk = event.headers || {};
                const sent = hk['x-api-key'] || hk['X-API-Key'] || hk['X-api-key'];
                if (!sent || sent !== API_KEY) {
                  responseStream.write(`data: ${JSON.stringify({ error: "unauthorized" })}\n\n`);
                  responseStream.end(); return;
                }
              }

              const body = typeof event.body === 'string' ? JSON.parse(event.body || '{}') : (event.body || {});
              const question = (body.question || '').trim();
              if (!question) {
                responseStream.write(`data: ${JSON.stringify({ error: "missing question" })}\n\n`);
                responseStream.end(); return;
              }

              const prompt = `You are a concise professional assistant. Answer clearly and helpfully.\n\nUser: ${question}\nAssistant:`;

              const payload = {
                anthropic_version: "bedrock-2023-05-31",
                max_tokens: 600,
                temperature: 0.2,
                messages: [{ role: "user", content: [{ type: "text", text: prompt }]}]
              };

              const req = bedrock.invokeModelWithResponseStream({
                modelId: MODEL_ID,
                accept: "application/json",
                contentType: "application/json",
                body: JSON.stringify(payload)
              });

              const stream = req.createReadStream();

              stream.on('data', (buf) => {
                try {
                  const line = buf.toString('utf-8').trim();
                  if (!line) return;
                  const parts = line.split(/\n/).filter(Boolean);
                  for (const p of parts) {
                    const evt = JSON.parse(p);
                    const delta = (evt?.delta && evt.delta.text) || evt?.output_text || "";
                    if (delta) responseStream.write(`data: ${JSON.stringify({ token: delta })}\n\n`);
                  }
                } catch (e) { console.error("Chunk parse error", e); }
              });

              stream.on('end', () => {
                responseStream.write(`event: done\ndata: {}\n\n`);
                responseStream.end();
              });

              stream.on('error', (err) => {
                console.error("Bedrock stream error", err);
                responseStream.write(`data: ${JSON.stringify({ error: err.message })}\n\n`);
                responseStream.end();
              });

            } catch (err) {
              console.error(err);
              responseStream.write(`data: ${JSON.stringify({ error: err.message })}\n\n`);
              responseStream.end();
            }
          });

  # Dedicated log group so we can retain logs for 14 days; name must match the function name convention
  ChatLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/HOPS-StreamingChat-${AWS::StackName}
      RetentionInDays: 14

  ChatFunctionUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !Ref ChatFunction
      AuthType: NONE
      Cors:
        AllowOrigins: ['*']
        AllowMethods: ['POST','OPTIONS']
        AllowHeaders: ['content-type','x-api-key','X-API-Key']

  ChatFunctionUrlPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ChatFunction
      Action: lambda:InvokeFunctionUrl
      Principal: "*"
      FunctionUrlAuthType: NONE

Outputs:
  FunctionUrl:
    Description: 'POST with {"question":"..."}; streaming via SSE. Include X-API-Key if you set AppApiKey.'
    Value: !Ref ChatFunctionUrl
  LambdaName:
    Description: Lambda function name
    Value: !Ref ChatFunction
